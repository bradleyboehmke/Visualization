{
    "collab_server" : "",
    "contents" : "---\ntitle: \"Quick Plots\"\nauthor: NULL\ndate: NULL\noutput:\n  html_document:\n    keep_md: true\n    fig_width: 4\n    fig_height: 4\n---\n\nFor quick data exploration, base R plotting functions can provide a quick and straightforward approach to understanding your data. These functions are installed by default with R and do not require additional visualization packages to be installed. This tutorial shows how to use these base functions for visualizations and I'll use data sets that come with R.  \n\nIn addition, I'll show how to make similar graphics with the `qplot()` function in `ggplot2`, which has a syntax similar to the base graphics functions. For each `qplot()` graph, there is also an equivalent using the more powerful `ggplot()` function which I illustrate in later visualization tutorials. This will, hopefully, help you transition to using `ggplot2` when you want to make more sophisticated graphics. \n\n- [Scatter plot](#scatter)\n- [Line chart](#line)\n- [Bar chart](#bar)\n- [Histogram](#histogram)\n- [Box plot](#box)\n- [Stem & leaf plot](#stem)\n\n<br>\n\n## Scatter Plot {#scatter}\nTo make a scatter plot use `plot()` with a vector of x values and a vector of y values:\n\n```{r, echo=TRUE, fig.align='center'}\n# base R\nplot(x = mtcars$wt, y = mtcars$mpg)\n```\n\nYou can get a similar result using `qplot()`:\n\n```{r, echo=TRUE, fig.align='center'}\nlibrary(ggplot2)\nqplot(x = mtcars$wt, y = mtcars$mpg)\n```\n\nIf the two vectors are already in the same data frame, note that the following functions produce the same outpt:\n\n```{r, echo=TRUE, eval=FALSE}\n\n# specifying only x and y vectors\nqplot(x = mtcars$wt, y = mtcars$mpg)\n\n# specifying x and y vectors from a data frame\nqplot(x = wt, y = mpg, data = mtcars)\n\n# using full ggplot syntax\nggplot(data = mtcars, aes(x = wt, y = mpg)) +\n        geom_point()\n```\n\n<a href=\"#top\">Go to top</a>\n\n<br>\n\n## Line Chart {#line}\nTo make a line graph using `plot()`, pass it the vector of x and y values, and specify type =\" l\" for *line*:\n\n```{r, echo=TRUE, fig.align='center'}\nplot(x = pressure$temperature, y = pressure$pressure, type = \"l\")\n```\n\nTo include multiple lines or to plot the points, first call `plot()` for the first line, then add additional lines and points with `lines()` and `points()` respectively: \n\n```{r, echo=TRUE, fig.align='center'}\n# base graphic\nplot(x = pressure$temperature, y = pressure$pressure, type = \"l\")\n\n# add points\npoints(x = pressure$temperature, y = pressure$pressure)\n\n# add second line in red color\nlines(x = pressure$temperature, y = pressure$pressure/2, col = \"red\")\n\n# add points to second line\npoints(x = pressure$temperature, y = pressure$pressure/2, col = \"red\")\n```\n\nWe can use `qplot()` to get similar results by using the `geom` argument. `geom` means adding a geometric object (line, points, etc.) to visually represent the data and in this case we want to represent the data using a line and then also points:\n\n```{r, echo=TRUE, fig.align='center'}\n# using qplot for a line chart\nqplot(temperature, pressure, data = pressure, geom = \"line\")\n\n# using qplot for a line chart with points\nqplot(temperature, pressure, data = pressure, geom = c(\"line\", \"point\"))\n```\n\nWe can get the same output using the full `ggplot()` syntax:\n```{r, echo=TRUE, eval=FALSE}\n# line chart\nggplot(pressure, aes(x = temperature, y = pressure)) +\n        geom_line()\n\n# line chart with points\nggplot(pressure, aes(x = temperature, y = pressure)) +\n        geom_line() +\n        geom_point()\n```\n\n\n<a href=\"#top\">Go to top</a>\n\n<br>\n\n## Bar Chart {#bar}\nTo make a bar chart of values, use `barplot()` and pass it a vector of values for the height of each bar and (optionally) a vector of labels for each bar. If the vector has names for the elements, the names will automatically be used as labels:\n\n```{r, echo=TRUE, fig.align='center'}\nbarplot(height = BOD$demand, names.arg = BOD$Time)\n```\n\nWhen you want the bar chart to represent the *count* of cases in each category then you need to generate the count of unique values. For instance, in the `mtcars` dataset we may want to look at the cylinder variable and understand the distribtion. To do this we can use the `table()` function which will provide us the count of each unique value in this variable.  We can then pass this to the `barplot()` function to plot the counts of cylinders:\n\n```{r, echo=TRUE, fig.align='center', collapse=TRUE}\n# the cylinder variable in the mtcars dataset is made up of values of 4, 6 & 8\nmtcars$cyl\n\n# get the count of 4, 6 & 8 cylinder cars in the dataset\ntable(mtcars$cyl)\n\n# plot the count of 4, 6 & 8 cylinder cars in the dataset\nbarplot(table(mtcars$cyl))\n```\n\nTo get the same result using `qplot()` we use `geom = \"bar\"`.\n\n```{r, echo=TRUE, fig.align='center'}\n# x defaults to a continuous variable\nqplot(mtcars$cyl, geom = \"bar\")\n\n# use factor(x) to make it discrete\nqplot(factor(mtcars$cyl), geom = \"bar\")\n```\n\n<a href=\"#top\">Go to top</a>\n\n<br>\n\n## Histogram {#histogram}\nTo make a histogram, use `hist()` and pass it a single vector of values. You can also use the `breaks` argument to determine the size of the bins.\n\n```{r, echo=TRUE, fig.align='center'}\n# default bins\nhist(mtcars$mpg)\n\n# adjust binning\nhist(mtcars$mpg, breaks = 10)\n```\n\nTo get the same result using `qplot()` we use don't need to specify a `geom` argument as when you feed `qplot()` with a single variable it will default to using a histogram. You can also control the binning by using the `binwidth` argument. Although not necessary I add the `color` argument to outline the bars.\n\n```{r, echo=TRUE, fig.align='center'}\nqplot(mtcars$mpg, binwidth = 3, color = I(\"white\"))\n```\n\n<a href=\"#top\">Go to top</a>\n\n<br>\n\n## Box Plot {#box}\nTo make a box-whisker plot (aka box plot), use plot() and pass it a <u>factor</u> of x values and a vector of y values. When x is a factor (as opposed to a numeric vector), it will automatically create a box plot:\n\n```{r, echo=TRUE, fig.align='center'}\n# if x is not a factor it will produce a scatter plot\nplot(mtcars$cyl, mtcars$mpg)\n\n# if x is a factor it will produce a box plot\nplot(factor(mtcars$cyl), mtcars$mpg)\n```\n\nAlternatively, we can use the `boxplot()` function to get the same results. In this case we use the \"~\" to state that we want to assess *y* by *x*.  \n\n```{r, echo=TRUE, fig.align='center'}\n# boxplot of mpg by cyl\nboxplot(mpg ~ cyl, data = mtcars)\n```\n\nWe can also assess interactions. In this case we look at the distribution of mpg by cylinders and V/S. Note on the y axis is mpg and on the x axis are the cylinder~V/S interaction. So the x-axis values of 4.0, 6.0, 8.0, 4.1, etc. represent 4 cylinder without V/S, 6 cylinder without V/S, 8 cylinder without V/S, 4 cylinder with V/S, etc. \n\n```{r, echo=TRUE, fig.align='center'}\n# boxplot of mpg based on interaction of two variables\nboxplot(mpg ~ cyl + am, data = mtcars)\n```\n\nSimilar results are attained with `qplot()` using `geom = \"boxplot\"`:\n\n```{r, echo=TRUE, fig.align='center'}\nqplot(x = factor(cyl), y = mpg, data = mtcars, geom = \"boxplot\")\n```\n\n<a href=\"#top\">Go to top</a>\n\n<br>\n\n## Stem & Leaf Plot {#stem}\nTo make a stem-and-leaf plot we can simply use the `stem()` function and pass it a vector of numeric values:\n\n```{r, echo=TRUE}\nstem(faithful$eruptions)\n```\n\n<a href=\"#top\">Go to top</a>\n\n",
    "created" : 1463407952382.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "131290283",
    "id" : "EA8086D4",
    "lastKnownWriteTime" : 1463500071,
    "last_content_update" : 1463500071730,
    "path" : "~/Desktop/Personal/Visualization/Quickplots.Rmd",
    "project_path" : "Quickplots.Rmd",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_markdown"
}