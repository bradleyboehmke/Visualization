{
    "collab_server" : "",
    "contents" : "---\ntitle: \"Bar Charts\"\nauthor: NULL\ndate: NULL\noutput:\n  html_document:\n    keep_md: true\n    fig_width: 4\n    fig_height: 3\n---\n\n\nBar charts are one of the most commonly used data visualizations. The primary purpose of a bar chart is to illustrate and compare the values for a set of *categorical* variables. To accomplish this, bar charts display the categorical variables of interest (typically) along the x-axis and the length of the bar illustrates the value along the y-axis. Consequently, the length of the bar is the primary visual cue in bar chart and this length can represent counts of cases in the data set or values for a second variable.\n\n<img src=\"Bar Charts/barchart_explanation.png\" style=\"display: block; margin: auto;\" />\n\n## tl;dr\nThis tutorial will cover how to go from a basic bar chart to a more refined, publication worthy graphic. If you're short on time jump to the sections of interest:\n\n- [Replication requirements](#replication)\n- [Basic bar chart](#basics)\n- [Comparing groups](#groups)\n- [Adding value markers](#markers)\n- [Finishing touches](#finishing)\n\n<br>\n\n## Relication Requirements {#replication}\nTo reproduce the code throughout this tutorial you will need to load the following packages. The primary package of interest is [`ggplot2`](http://ggplot2.org/), which is a plotting system for R. You can build bar charts with [base R graphics](http://bradleyboehmke.github.io/tutorials/quickplots#bar), but when I'm building more refined graphics I lean towards `ggplot2`.\n\n```{r, echo=TRUE, message=FALSE, warning=FALSE, collapse=TRUE}\nlibrary(xlsx)           # for reading in Excel data\nlibrary(dplyr)          # for data manipulation\nlibrary(tidyr)          # for data manipulation\nlibrary(magrittr)       # for easier syntax in one or two areas\nlibrary(gridExtra)      # for generating some comparison plots\nlibrary(ggplot2)        # for generating the visualizations\n```\n\n&#9755; *See [Working with packages](http://bradleyboehmke.github.io/tutorials/basics/packages/) for more information on installing, loading, and getting help with packages.*\n\nIn addition, for most of my examples I will illustrate with the built in `mtcars` data set.  However, for the final section I use some data that comes from Pew Research on [America's shrinking middle class](http://www.pewsocialtrends.org/2016/05/11/americas-shrinking-middle-class-a-close-look-at-changes-within-metropolitan-areas/). You can obtain the data from [here]( http://www.pewsocialtrends.org/files/2016/05/Middle-Class-U.S.-Metro-Areas-5-12-16-Supplementary-Tables.xlsx).  After importing and cleaning up the worksheet a bit the data looks as follows, which includes the distribution of adults by income tiers in 2000 and 2014 across 229 metro locations across the U.S.\n\n```{r, echo=TRUE, message=FALSE, warning=FALSE, collapse=TRUE, cache=TRUE}\n# read in PEW data\nincome <- read.xlsx(\"Data/PEW Middle Class Data.xlsx\",\n                    sheetIndex = \"1. Distribution, metro\",\n                    startRow = 10, colIndex = c(1:4, 6:8)) %>%\n        set_colnames(c(\"Metro\", \"Lower_00\", \"Middle_00\", \"Upper_00\", \"Lower_14\",\n                       \"Middle_14\", \"Upper_14\")) %>%\n        filter(Metro != \"NA\")\n\nhead(income)\n```\n\n```{r, message=FALSE, warning=FALSE, echo=FALSE}\ntheme_update(plot.background = element_rect(fill = \"#fdfdfd\"),\n             legend.background = element_blank())\n```\n\n<br>\n\n## Basic Bar Chart {#basics}\nAs mentioned in the introduction bar charts are used to represent either the counts of cases of each category *or* the values of a second variable for each category.  For instance, the `mtcars` data set comprises fuel consumption and 10 aspects of automobile design and performance for 32 automobiles. \n\n```{r, echo=TRUE, message=FALSE, warning=FALSE, collapse=TRUE, cache=TRUE}\nhead(mtcars)\n```\n\nIf we wanted to get the count of vehicles that have 4, 6 and 8 cylinders we can simply identify the x-axis variable and apply `geom_bar()`. This, by default will plot the count of 4, 6, and 8 cylinder vehicles in the data set. However, note that if the variable is numeric it may be interpreted as a continous variable. This is the case in Fig. A which is why the x-axis is continous in nature. We can force the cylinder variable to a categorical (factor) variable by applying `x = factor(cyl)` as in Fig. B, which produces a discrete x-axis.\n\n\n```{r, echo=TRUE, message=FALSE, warning=FALSE, collapse=TRUE, cache=TRUE, fig.width=8.5, fig.height=3, fig.align='center'}\nlibrary(ggplot2)\nlibrary(gridExtra)\n\n# x-axis as continuous\np1 <- ggplot(mtcars, aes(x = cyl)) +\n        geom_bar() +\n        ggtitle(\"Fig. A: x-axis as a continuous variable\")\n\n# x-axis as categorical\np2 <- ggplot(mtcars, aes(x = factor(cyl))) +\n        geom_bar() +\n        ggtitle(\"Fig B: x-axis as a categorical (factor) variable\")\n\ngrid.arrange(p1, p2, ncol = 2)\n```\n\nAn alternative use of a bar chart is to plot a second variable on the y-axis to compare the x-axis categories across.  For instance, we may want to assess the average mpg that 4, 6, and 8 cylinder cars get. To do this, we first calculate the average mpg for each cylinder and then incorprate mpg as the y-axis variable. We also need to include the argument `stat = \"identity\"` in `geom_bar()` which tells R to use the y values for the height of the bars.\n\n```{r, echo=TRUE, message=FALSE, warning=FALSE, collapse=TRUE, cache=TRUE, fig.width=4, fig.height=3, fig.align='center'}\nlibrary(dplyr)\n\ncyl_mpg <- mtcars %>%\n        group_by(cyl) %>%\n        summarise(avg_mpg = mean(mpg, na.rm = TRUE))\n\nggplot(cyl_mpg, aes(x = factor(cyl), y = avg_mpg)) +\n        geom_bar(stat = \"identity\")\n```\n\nAlthough the default width of the bars is aesthetically pleasing, you do have the ability to adjust this attribute by setting the `width` in `geom_bar()`.  The default width is 0.9; smaller values make the bars narrower and larger values (max width of 1) make the bars wider.\n\n```{r, echo=TRUE, message=FALSE, warning=FALSE, collapse=TRUE, cache=TRUE, fig.width=10, fig.height=3, fig.align='center'}\np1 <- ggplot(mtcars, aes(x = factor(cyl))) +\n        geom_bar(width = .5) +\n        ggtitle(\"bar width = 0.5\")\n        \n\np2 <- ggplot(mtcars, aes(x = factor(cyl))) +\n        geom_bar(width = .75) +\n        ggtitle(\"bar width = 0.75\")\n\np3 <- ggplot(mtcars, aes(x = factor(cyl))) +\n        geom_bar(width = .9) +\n        ggtitle(\"bar width = 0.9\")\n\np4 <- ggplot(mtcars, aes(x = factor(cyl))) +\n        geom_bar(width = .99) +\n        ggtitle(\"bar width = 0.99\")\n\ngrid.arrange(p1, p2, p3, p4, ncol = 4)\n```\n\nWe can also adjust the fill and outline colors of the bars along with the opacity by applying `fill`, `color`, and `alpha` arguments respectively in the `geom_bar()` function.\n\n```{r, echo=TRUE, message=FALSE, warning=FALSE, collapse=TRUE, cache=TRUE, fig.width=4, fig.height=3, fig.align='center'}\nggplot(mtcars, aes(x = factor(cyl))) +\n        geom_bar(fill = \"dodgerblue\", color = \"grey40\", alpha = .5)\n```\n\nThere are also times when we want to plot many categories along the x-axis and the length of the names make it difficult to read. One approach to resolving this issue is to use `axis.text.x` argument within the `theme()` function to rotate the text.\n\n```{r, echo=TRUE, message=FALSE, warning=FALSE, collapse=TRUE, cache=TRUE, fig.width=5, fig.height=10, fig.align='center'}\np1 <- ggplot(mtcars, aes(x = row.names(mtcars), y = mpg)) +\n        geom_bar(stat = \"identity\") +\n        ggtitle(\"Fig. A: Default x-axis\")\n\np2 <- ggplot(mtcars, aes(x = row.names(mtcars), y = mpg)) +\n        geom_bar(stat = \"identity\") +\n        theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = .5)) +\n        ggtitle(\"Fig. B: Rotated x-axis\")\n\ngrid.arrange(p1, p2, ncol = 1)\n```\n\nHowever, if you're like me then you probably hate to read rotated x-axis labels.  In cases like these I think rotated bar charts are far more appealing. We can rotate the the axes by applying the `coord_flip()` function, which flips the x and y coordinates. To make this even easier to digest we can order the vehicles based on their mpg values as illustrated in Fig B. To do this just reorder the x variable by applying the `reorder()` function. \n\n```{r, echo=TRUE, message=FALSE, warning=FALSE, collapse=TRUE, cache=TRUE, fig.width=10, fig.height=7, fig.align='center'}\n# rotate to make more readable\np1 <- ggplot(mtcars, aes(x = row.names(mtcars), mpg)) +\n        geom_bar(stat = \"identity\") +\n        coord_flip() +\n        ggtitle(\"Fig. A: Default rotated x-axis\")\n\n# order bars\np2 <- ggplot(mtcars, aes(x = reorder(row.names(mtcars), mpg), y = mpg)) +\n        geom_bar(stat = \"identity\") +\n        coord_flip() +\n        ggtitle(\"Fig. B: Rotated ordered x-axis\")\n\ngrid.arrange(p1, p2, ncol = 2)\n```\n\n<a href=\"#top\">Go to top</a>\n\n<br>\n\n## Comparing Groups {#groups}\nSometimes we want to compare different groups across the categorical variables of interest. This is primarily done via color, side-by-side bars, or stacked bars. To add a color dimension we simply add a `fill` argument to our first line of code to tell R what variable we want to use to color our bars. In this example we compare mpg across all the vehicles but also color the vehicles based on number of cylinders. R will use default color codings but you can set the colors manually using `scale_fill_manual` as in Fig. B; you can also use `scale_fill_hue` to change the hue across vehicles, `scale_fill_brewer` to color with preset color schemes (see more about ColorBrewer at [http://colorbrewer2.org](http://colorbrewer2.org )), etc. There are many coloring options and if you type scale_fill into your RStudio help search field you will see all the possibilities. \n\n```{r, echo=TRUE, message=FALSE, warning=FALSE, collapse=TRUE, cache=TRUE, fig.width=10, fig.height=7, fig.align='center'}\n# compare mpg across all cars and color based on cyl\np1 <- ggplot(mtcars, aes(x = reorder(row.names(mtcars), mpg), y = mpg, fill = factor(cyl))) +\n        geom_bar(stat = \"identity\") +\n        coord_flip() +\n        theme_minimal() +\n        ggtitle(\"Fig. A: Default fill colors\")\n\np2 <- ggplot(mtcars, aes(x = reorder(row.names(mtcars), mpg), y = mpg, fill = factor(cyl))) +\n        scale_fill_manual(values = c(\"#e5f5e0\", \"#a1d99b\", \"#31a354\")) +\n        geom_bar(stat = \"identity\") +\n        coord_flip() +\n        theme_minimal() +\n        ggtitle(\"Fig. B: Manually set fill colors\")\n\ngrid.arrange(p1, p2, ncol = 2)\n```\n\nWe can also use side-by-side bars to make comparisons. Say we want to compare the average mpg for cars across the different 4, 6, and 8 cylinder categories but also assess the impact that transmission (variable `am` where 0 = automatic, 1 = manual) has.  In this case we want to first summarize our data by calculating mean mpg by cylinder and transmission and then we apply the `fill` argument to color bars based on transmission type then include the `position = \"dodge\"` in the `geom_bar()` function. This tells R to have two bars for each cylinder type, color fill each bar based on the type of transmission and then adjust (aka \"dodge\") the position of the bars so that they are side-by-side.\n\n```{r, echo=TRUE, message=FALSE, warning=FALSE, collapse=TRUE, cache=TRUE, fig.width=10, fig.height=3, fig.align='center'}\nlibrary(dplyr)\navg_mpg <- mtcars %>%\n        group_by(cyl, am) %>%\n        summarise(mpg = mean(mpg, na.rm = TRUE))\n\navg_mpg\n\np1 <- ggplot(avg_mpg, aes(factor(cyl), mpg, fill = factor(am))) +\n        geom_bar(stat = \"identity\", position = \"dodge\") +\n        ggtitle(\"Default color comparison\")\n\n# more pleasing colors\np2 <- ggplot(avg_mpg, aes(factor(cyl), mpg, fill = factor(am))) +\n        geom_bar(stat = \"identity\", position = \"dodge\", color = \"grey40\") +\n        scale_fill_brewer(palette = \"Pastel1\") +\n        ggtitle(\"Adjusted color comparison\")\n\ngrid.arrange(p1, p2, ncol = 2)\n```\n\nYou can adjust the dodge width by incorporating the `position = position_dodge(width = x)` argument in the `geom_bar()` function. By default, the width is .90 and a lower value will create overlap of your side-by-side bars and a larger value will create spacing between the bars. \n\n```{r, echo=TRUE, message=FALSE, warning=FALSE, collapse=TRUE, cache=TRUE, fig.width=10, fig.height=3, fig.align='center'}\np1 <- ggplot(avg_mpg, aes(factor(cyl), mpg, fill = factor(am))) +\n        geom_bar(stat = \"identity\", position = \"dodge\") +\n        ggtitle(\"Default dodge positioning\") +\n        theme(legend.position = \"none\")\n\np2 <- ggplot(avg_mpg, aes(factor(cyl), mpg, fill = factor(am))) +\n        geom_bar(stat = \"identity\", position = position_dodge(width = .5)) +\n        ggtitle(\"Overlap of side-by-side bars\") +\n        theme(legend.position = \"none\")\n\np3 <- ggplot(avg_mpg, aes(factor(cyl), mpg, fill = factor(am))) +\n        geom_bar(stat = \"identity\", position = position_dodge(width = 1)) +\n        ggtitle(\"Spacing between side-by-side bars\") +\n        labs(fill = \"AM\") +\n        theme(legend.position = c(1,1), legend.justification = c(1,1),\n              legend.background = element_blank())\n\ngrid.arrange(p1, p2, p3, ncol = 3)\n```\n\n\nStacked bars are the third common approach to compare groups with bar charts. By default, when you introduce a variable to color fill with in the first line, if you enter no other arguments ggplot will produce a stacked bar chart.\n\n```{r, echo=TRUE, message=FALSE, warning=FALSE, collapse=TRUE, cache=TRUE, fig.width=4, fig.height=3, fig.align='center'}\nggplot(avg_mpg, aes(factor(cyl), mpg, fill = factor(am))) +\n        geom_bar(stat = \"identity\")\n```\n\nUnfortunately, the way ggplot color codes the bars is opposite to how the colors are displayed in the legend. We can resolve this two different ways; either reverse the legend with the arguments displayed in the `guides()` function in Fig A. or [specify the direction of the levels](http://bradleyboehmke.github.io/tutorials/factors#order) when transforming the transmission (`am`) variable into a factor as displayed in the first line of code in Fig B. Both will align the legend color coding layout to the color coding of the stacked bars but each option also helps determine which color is top versus on the bottom.\n\n```{r, echo=TRUE, message=FALSE, warning=FALSE, collapse=TRUE, cache=TRUE, fig.width=8, fig.height=3, fig.align='center'}\n\n# Reverse legend color coding layout\np1 <- ggplot(avg_mpg, aes(factor(cyl), mpg, fill = factor(am))) +\n        geom_bar(stat = \"identity\") +\n        guides(fill = guide_legend(reverse = TRUE)) +\n        labs(fill = \"am\") +\n        ggtitle(\"Fig A: Reverse legend\")\n\n# or reverse stacking order by changing the factor levels\np2 <- ggplot(avg_mpg, aes(factor(cyl), mpg, fill = factor(am, levels = c(1, 0)))) +\n        geom_bar(stat = \"identity\") +\n        labs(fill = \"am\") +\n        ggtitle(\"Fig B: Specify levels\")\n\ngrid.arrange(p1, p2, ncol = 2)\n```\n\nAnd as before we can change the color of our stacked bars by incorporating one of the many `scale_fill_xxxx` arguments. Here I manually specify the colors to apply with `scale_fill_manual()`.\n\n```{r, echo=TRUE, message=FALSE, warning=FALSE, collapse=TRUE, cache=TRUE, fig.width=4, fig.height=3, fig.align='center'}\nggplot(avg_mpg, aes(factor(cyl), mpg, fill = factor(am, levels = c(1, 0)))) +\n        geom_bar(stat = \"identity\", color = \"grey40\") +\n        scale_fill_manual(values = c(\"#a1d99b\", \"#31a354\")) +\n        labs(fill = \"AM\")\n```\n\nA common version of the stacked bar chart that you will see is the proportional stacked bar chart. In the proportional stacked bar chart each x-axis category will have stacked bars that combine to equal 100%. This allows you to see what percentage of that x-axis category is determined by an additional variable. For example, what if we want to understand what percentage of cars with 4, 6, and 8 cylinders are manual versus automatic transmission? In this case, we first tally the number of vehicles in each cylinder and transmission category and then calculate the percentages of the total cars in each cylinder category. We then use this information to create a stacked bar chart. \n\n```{r, echo=TRUE, message=FALSE, warning=FALSE, collapse=TRUE, cache=TRUE, fig.width=4, fig.height=3, fig.align='center'}\n# calculate percentages of each cyl & am category\nproportion <- mtcars %>%\n        group_by(cyl, am) %>%\n        tally() %>%\n        group_by(cyl) %>%\n        mutate(pct = n / sum(n))\n\nproportion\n\n# create proportional stacked bars\nggplot(proportion, aes(factor(cyl), pct, fill = factor(am, levels = c(1, 0)))) +\n        geom_bar(stat = \"identity\", color = \"grey40\") +\n        scale_fill_manual(values = c(\"#a1d99b\", \"#31a354\")) +\n        labs(fill = \"AM\")\n```\n\n\n<a href=\"#top\">Go to top</a>\n\n<br>\n\n## Add Value Markers {#markers}\nOften, it is helpful to provide labels/markers on the bar charts to help the reader interpret the results correctly or just to make it easier to read the graphic. For instance, we can add the actual mpg value to the following vertical bar chart by incorporating the `geom_text()` function and telling the function to label each bar with the mpg value. I can also tell ggplot to nudge the values left or right sit within or outside the bar and also color the text.\n\n```{r, echo=TRUE, message=FALSE, warning=FALSE, collapse=TRUE, cache=TRUE, fig.width=10, fig.height=7, fig.align='center'}\np1 <- ggplot(mtcars, aes(reorder(row.names(mtcars), mpg), mpg)) +\n        geom_bar(stat = \"identity\") +\n        coord_flip() +\n        geom_text(aes(label = mpg), nudge_y = 2)\n\np2 <- ggplot(mtcars, aes(reorder(row.names(mtcars), mpg), mpg)) +\n        geom_bar(stat = \"identity\") +\n        coord_flip() +\n        geom_text(aes(label = mpg), nudge_y = -2, color = \"white\")\n\ngrid.arrange(p1, p2, ncol = 2)\n```\n\nIf you want to draw attention to one specific bar you can create a new `TRUE/FALSE` variable that marks the specific vehicle of interest. In the following case I also add the Make of the car as a variable since the mtcars only uses the make as a row name, which can be erased when making changes to the data frame.  You can then fill by the new ID variable in the first line of code and use `annotate()` to specify the exact text you want to highlight for that bar.\n\n```{r, echo=TRUE, message=FALSE, warning=FALSE, collapse=TRUE, cache=TRUE, fig.width=5, fig.height=7, fig.align='center'}\ncars <- mtcars %>%\n        mutate(Make = row.names(mtcars),\n               ID = ifelse(Make == \"Fiat X1-9\", TRUE, FALSE))\n\nggplot(cars, aes(reorder(Make, mpg), mpg, fill = ID)) +\n        geom_bar(stat = \"identity\") +\n        coord_flip() +\n        scale_fill_manual(values = c(\"grey90\", \"dodgerblue\")) +\n        annotate(\"text\", x = \"Fiat X1-9\", y = 22, label = \"mpg = 27.3\", color = \"white\") +\n        theme_minimal() +\n        theme(legend.position = \"none\")\n```\n\nLabelling grouped bars is similar, however, we need to add a `position = position_dodge(0.9)` argument to the `geom_text()` function to tell ggplot to adjust the text location. By default, the values will be centered on the top of the bar (Fig. A) but you can adjust the text to the top of the bar by including a `vjust = .5` argument or adjust the text to within the bar with `vjust = 1.5` (Fig. B).\n\n```{r, echo=TRUE, message=FALSE, warning=FALSE, collapse=TRUE, cache=TRUE, fig.width=10, fig.height=3, fig.align='center'}\np1 <- ggplot(avg_mpg, aes(factor(cyl), mpg, fill = factor(am))) +\n        geom_bar(stat = \"identity\", position = \"dodge\") +\n        geom_text(aes(label = round(mpg, 1)), position = position_dodge(0.9)) +\n        ggtitle(\"Fig A: Default text alignment\")\n\np2 <- ggplot(avg_mpg, aes(factor(cyl), mpg, fill = factor(am))) +\n        geom_bar(stat = \"identity\", position = \"dodge\") +\n        geom_text(aes(label = round(mpg, 1)), position = position_dodge(0.9),\n                  vjust = 1.5, color = \"white\") +\n        ggtitle(\"Fig B: Adjusted text alignment\")\n\ngrid.arrange(p1, p2, ncol = 2)\n```\n\nTo add labels to a proportional bar chart we need to create a new variable in or data frame to specify the location. To do this I create a `label_y` variable that just `cumsum`s the proportions for each cylinder. You can then map the label variables to these values by incorporating the `y = label_y` argument in `geom_text()` which will place the labels at the top of of each stacked proportion bar.\n\n```{r, echo=TRUE, message=FALSE, warning=FALSE, collapse=TRUE, cache=TRUE, fig.width=4, fig.height=3, fig.align='center'}\n# create label location for each proportional bar\nproportion <- proportion %>%\n        group_by(cyl) %>%\n        mutate(label_y = cumsum(pct))\n\nggplot(proportion, aes(factor(cyl), pct, fill = factor(am, levels = c(1, 0)))) +\n        geom_bar(stat = \"identity\", color = \"grey40\") +\n        geom_text(aes(label = round(pct, 2), y = label_y), vjust = 1.5, color = \"white\") +\n        scale_fill_manual(values = c(\"#a1d99b\", \"#31a354\")) +\n        labs(fill = \"AM\")\n```\n\n\n<a href=\"#top\">Go to top</a>\n\n<br>\n\n## Finishing Touches {#finishing}\nWe can bring a lot of these components together, plus add some nice finishing touches to create a publication worthy. To illustrate I'll use the `income` data that we imported in the [Replication Requirements section](#replication); however, being that I live in Dayton, OH I am primarily interested in assessing how the distribution of adults by income tier has changed from 2000 to 2014. To assess this let's first filter our data to focus just on the Dayton, OH metro area and then create our basic categories to compare the percent of adults across. \n\n```{r, echo=TRUE, message=FALSE, warning=FALSE, collapse=TRUE, cache=TRUE}\ndayton <- income %>%\n        filter(Metro == \"Dayton, OH\") %>%\n        gather(metric, value, -Metro) %>%\n        separate(metric, into = c(\"class\", \"year\")) %>%\n        mutate(year = ifelse(year == \"00\", 2000, 2014),\n               value = value/100)\n\ndayton\n```\n\nWe can now create our basic bar chart that is a side-by-side comparison.\n\n```{r, echo=TRUE, message=FALSE, warning=FALSE, collapse=TRUE, cache=TRUE, fig.width=6, fig.height=4, fig.align='center'}\nplot <- ggplot(dayton, aes(x = class, y = value, fill = factor(year))) +\n        geom_bar(stat = \"identity\", position = \"dodge\", color = \"grey40\")+\n        scale_fill_manual(values = c(\"#a1d99b\", \"#31a354\"))\n\nplot\n```\n\nNow let's add some labels to the plot; however, I want to create nicely formatted labels so rather than just use the `value` variable I'll create a new `y_label` variable with a percent formatted number.  We can now add these values to our plot with `geom_text()`.\n\n```{r, echo=TRUE, message=FALSE, warning=FALSE, collapse=TRUE, cache=TRUE, fig.width=6, fig.height=4, fig.align='center'}\ndayton <- dayton %>%\n        mutate(y_label = paste0(round(value*100, 1), \"%\"))\n\ndayton\n\n plot <- ggplot(dayton, aes(x = class, y = value, fill = factor(year))) +\n         geom_bar(stat = \"identity\", position = \"dodge\", color = \"grey40\") +\n         scale_fill_manual(values = c(\"#a1d99b\", \"#31a354\")) +\n         geom_text(aes(label = y_label), position = position_dodge(0.9),\n                   vjust = 1.5, color = \"white\", family = \"Georgia\")\n\nplot\n```\n\n\nThis is looking pretty good but now let's add some clarity to our message by making the y axis displayed in percent form via `scale_y_continuous()`, create better labels for our x-axis categories via `scale_x_discrete()`, and add a title, subtitle and caption via `labs()`.\n\n```{r, echo=TRUE, message=FALSE, warning=FALSE, collapse=TRUE, cache=TRUE, fig.width=8, fig.height=5, fig.align='center'}\nplot <- plot +\n        scale_y_continuous(labels = scales::percent) +\n        scale_x_discrete(labels = c(\"Lower\" = \"Lower Class\",\n                         \"Middle\" = \"Middle Class\", \"Upper\" = \"Upper Class\")) +\n        labs(title = \"Distribution of Adults by Income in Dayton, OH\",\n             subtitle = \"The percentage of adults in the middle class eroded by 5.3% from 2000 to 2014. Although a small \\nfraction of these individuals moved into the upper class (+0.5%), the majority of these middle class \\nindividuals moved into the lower income class (+4.8%).\",\n             caption = \"Source: Pew Research Center analysis of the \\n2000 decennial census and 2014 American \\nCommunity Survey (IPUMS)\")\n\nplot\n```\n\nLastly, let's do some theme editing.  I usually use a minimalistic plot so I set my base theme via `theme_minimal()`. Next, I remove axis titles since it become self explanatory through the title and subtitle. I also remove unecessary gridlines, rotate the legend, set the font family, and then do some title, subtitle, and caption editing. \n\n```{r, echo=TRUE, message=FALSE, warning=FALSE, collapse=TRUE, cache=TRUE, eval=FALSE}\nplot +\n        theme_minimal() +\n        theme(axis.title = element_blank(),\n              panel.grid.major.x = element_blank(),\n              panel.grid.minor = element_blank(),\n              legend.position = c(1,1), legend.justification = c(1,1),\n              legend.background = element_blank(),\n              legend.direction=\"horizontal\",\n              legend.title = element_blank(),\n              text = element_text(family = \"Georgia\"),\n              plot.title = element_text(size = 20, margin = margin(b = 10)),\n              plot.subtitle = element_text(size = 12, color = \"darkslategrey\", margin = margin(b = 25)),\n              plot.caption = element_text(size = 8, margin = margin(t = 10), color = \"grey70\", hjust = 0))\n        \n```\n\n```{r, echo=FALSE, message=FALSE, warning=FALSE, collapse=TRUE, cache=TRUE, fig.width=8, fig.height=5, fig.align='center'}\nplot +\n        theme_minimal() +\n        theme(axis.title = element_blank(),\n              panel.grid.major.x = element_blank(),\n              panel.grid.minor = element_blank(),\n              legend.position = c(1,1), legend.justification = c(1,1),\n              legend.background = element_blank(),\n              legend.direction=\"horizontal\",\n              legend.title = element_blank(),\n              text = element_text(family = \"Georgia\"),\n              plot.title = element_text(size = 20, margin = margin(b = 10)),\n              plot.subtitle = element_text(size = 12, color = \"darkslategrey\", margin = margin(b = 25)),\n              plot.caption = element_text(size = 8, margin = margin(t = 10), color = \"grey70\", hjust = 0),\n              plot.background = element_rect(fill = \"#fdfdfd\", color = \"#fdfdfd\"))\n        \n```\n\n<a href=\"#top\">Go to top</a>\n\n<br>\n\n\n## Wrapping Up\nBar charts are a common chart that can simplistically illustrate and compare your data. When refined, they can easily communicate important aspects of your data to viewers. Hopefully this sheds some light on how to get started developing and refining bar charts with `ggplot`. \n\n<a href=\"#top\">Go to top</a>\n\n<br>",
    "created" : 1465310959486.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "1|19|4|0|\n10|0|25|0|\n27|41|61|0|\n62|28|168|0|\n",
    "hash" : "3040527219",
    "id" : "109DFDA0",
    "lastKnownWriteTime" : 1465412549,
    "last_content_update" : 1465568515620,
    "path" : "~/Desktop/Personal/Visualization/Barchart.Rmd",
    "project_path" : "Barchart.Rmd",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 8,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_markdown"
}